### 1. OSI 七层协议
- 应用层
  - 为应用提供通信服务
- 表示层
  - 定义数据格式以及加密
- 会话层
  - 定义了如何开始、控制、结束一个会话，包括对多个双向消息的控制和管理。
- 传输层
  - 选择差错恢复协议还是无差错恢复协议
  - TCP、UDP
- 网络层
  - 端到端包传输。
  - 路由选择、包分解成更小的包
- 数据链路层
  - 定义单个链路上如何传输数据
- 物理层
  - 传输介质相关

### 2. TCP
TCP（Transmission Control Protocol），又叫传输控制协议。 TCP协议是面向连接的，可靠的，基于字节流的传输协议。在基于 TCP 进行通信时，通信双方需要先建立一个 TCP 连接，建立连接需要经过三次握手，断开连接的时候需要经过四次挥手。

#### 2.1 三次握手
![](images/thr-handshake.png)

- 第一次握手  
  - SYN = 1， seq(client) = x  
  - 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

- 第二次握手  
  - SYN = 1，ACK = 1，确认序号 = x+1, seq(server) = y
  - 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态

- 第三次握手  
  - ACK = 1，确认序号 = y+1, seq(client) = x + 1
  - 客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

**为什么不用两次握手？**  
主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。  

假设有这样一种场景, 客户端发送的第一个请求连接并且没有丢失，但是被滞留的时间太长。由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送报文。 而现在第一个请求到达服务端，这个请求已经报废了，但是又会建立连接。 
  
如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

#### 2.2 四次挥手
![](images/quarticBye.png)

TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。

- 第一次挥手  
  - 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。

- 第二次挥手
  - B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。

- 第三次挥手
  - B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入LAST-ACK状态。
  - PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。

- 第四次挥手
  - A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

**为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？**  
为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。

**为什么建立连接是三次握手，关闭连接确是四次挥手呢？**  
建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了
