### 1. 编码优化
编码优化，指的就是 在代码编写时的，通过一些 最佳实践，提升代码的执行性能。通常这并不会带来非常大
的收益，但这属于 程序猿的自我修养，而且这也是面试中经常被问到的一个方面，考察自我管理与细节的处理。

- 数据读取：
    通过作用域链 / 原型链读取变量或方法时，需要更多耗时，且对象嵌套越深，读取值也越慢；
    - 尽量在局部作用域中进行变量缓存；
    - 避免嵌套过深的数据结构，数据扁平化有利于数据的读取和维护；

- 循环：
    循环通常是编码性能的关键点，代码的吸能问题会在循环中被指数呗放大；
    - 尽可能减少循环次数
        - 减少遍历的数据量
        - 完成目的后马上结束循环
    - 避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用缓存；
    - js中使用倒序循环会略微提升性能
    - 将数组长度存储在变量中
    - while循环耗时低于for循环
    - 尽量避免使用for-in循环，因为它会枚举原型对象，耗时大于普通循环；

- 条件流程性能：Map/Object > switch > if-else

- 减少cookie体积：
    cookie会随请求发送到服务端，减少cookie体积能有效减少每次请求的体积和相应时间
    - 去除不必要的cookie
    - 压缩cookie大小
    - 设置domain与过期时间
  
- dom优化
    - 减少访问dom次数，如需多次，将dom缓存与变量中；
    - 减少重绘与重排：
        - 多次操作合并为一次；
        - 减少对计算属性的访问
            - 例如offsetTop, getComputedStyle等；因为浏览器需要获取最新准确的值，因此必须立刻进行
            重排，这样会破坏浏览器的队列整合，尽量将值进行缓存使用
        - 大量操作时，可将dom脱离文档流或者隐藏，待操作完成后再重新恢复；
        - 使用DocumentFragment / cloneNode / replaceChild进行操作；
    - 使用事件委托，避免大量的事件绑定；

- css优化
    - 层级扁平，避免过于多层级的选择器嵌套；
    - 特定的选择器好过一层层查找： `.xxx-child-text{}`优于`.xxx .child .text{}`
    - 减少使用通配符与属性选择器；
    - 减少不必要的多余属性；
    - 使用动画属性实现动画，动画时脱离文档流，开启硬件加速，优先使用css动画；
    - 使用`<link>`代替原生`@import`；

- html优化
    - 减少dom数量，避免不必要的节点或嵌套；
    - 避免`<img src="" />`空标签，能减少服务器压力，因为src为空时，浏览器仍然会发起请求
        - IE向页面所在目录发送请求；
        - Safari、Chrome、Firefox向页面本身发送请求；
        - Opera不执行任何操作；
    - 图片提前指定宽高或者脱离文档流，能有效减少因图片加载导致的页面回流；
    - 语义化标签有利于SEO与浏览器的解析事件；
    - 减少使用table进行布局，避免使用`<br />`与`<hr />`；
    
### 2. 页面基础优化
- 引入位置：
    - css文件head中引入，js文件body底部引入
    - 影响首屏的，优先级很高的js也可以头部引入，甚至内联；
- 减少请求，合并请求，正确设置http缓存；
- 减少文件体积
    - 删除多余代码
        - tree-shaking
        - UglifyJs
        - code-spliting
    - 混淆 / 压缩代码， 开启gzip压缩；
    - 多份编译按条件引入：
        - 针对现代浏览器直接给ES6文件，只针对低端浏览器引用编译后的ES5文件；
        - 可以利用`<script type="module"> / <script type="module">`进行条件引入
    - 动态polyfill，只针对不支持的浏览器引入polyfill
- 图片优化
    - 根据业务场景，徐泽合适质量、合适尺寸、合适格式；
    - 小图片合成雪碧图，低于5K的图片可以转换成base64内嵌；
    - 合适场景下，使用iconfont或者svg；
- 使用缓存
    - 浏览器缓存：通过设置请求的过期时间，合理运用浏览器缓存；
    - CDN缓存：静态文件合理使用CDN缓存技术；
        - html放于自己的服务器上；
        - 打包后的图片/js/css等资源上传到CDN上，文件带上hash值；
        - 由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的CDN上，绕开该限制；
    - 服务器缓存：将不变的数据、页面缓存到内容或远程存储（redis等）上；
    - 数据缓存：通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；

### 3. 首屏渲染优化
- css/js分割，使首屏依赖的文件体积最小，内联首屏关键css/js；
- 非关键性文件尽可能使用异步加载和懒加载，避免阻塞首页渲染；
- 使用dns-prefetch / preconnect / prefetch / preload 等浏览器提供的资源提示，加快文件传输；
- 谨慎控制好Web字体
    - 控制字体包的加载时机；
    - 如果使用的字体有限，那尽可能将只使用的文字单独打包，能有效减少体积；
- 合理利用localStorage / server-worker等存储方式进行数据与资源缓存；
- 分清轻重缓急：
    - 重要的元素优先渲染
    - 视窗内的元素优先渲染
- 服务器渲染（SSR）：
    - 减少首屏需要的数据量，剔除冗余数据和请求；
    - 控制好缓存，对数据/页面进行合理的缓存；
    - 页面的请求使用流的形式进行传输；
- 优化用户感知：
    - 利用一些动画过渡效果，能有效减少用户对卡顿的感知；
    - 尽可能利用骨架屏（Placeholder）/Loading等减少用户对白屏的感知；
    - 动画帧数尽量保证在30帧以上；
    - js执行时间避免超过100ms
        - 寻找可缓存的点；
        - 任务的分割异步或web worker执行；
